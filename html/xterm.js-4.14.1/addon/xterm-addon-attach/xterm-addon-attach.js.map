{"version":3,"file":"xterm-addon-attach.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAqB,YAAID,IAEzBD,EAAkB,YAAIC,IARxB,CASGK,MAAM,WACT,M,sHCGA,iBAKE,WAAYC,EAAmBC,GAFvB,KAAAC,aAA8B,GAGpCC,KAAKC,QAAUJ,EAEfG,KAAKC,QAAQC,WAAa,cAC1BF,KAAKG,iBAAmBL,IAAqC,IAA1BA,EAAQM,eA6C/C,OA1CS,YAAAC,SAAP,SAAgBC,GAAhB,WACEN,KAAKD,aAAaQ,KAChBC,EAAkBR,KAAKC,QAAS,WAAW,SAAAQ,GACzC,IAAMC,EAA6BD,EAAGC,KACtCJ,EAASK,MAAsB,iBAATD,EAAoBA,EAAO,IAAIE,WAAWF,QAIhEV,KAAKG,iBACPH,KAAKD,aAAaQ,KAAKD,EAASO,QAAO,SAAAH,GAAQ,SAAKI,UAAUJ,OAC9DV,KAAKD,aAAaQ,KAAKD,EAASS,UAAS,SAAAL,GAAQ,SAAKM,YAAYN,QAGpEV,KAAKD,aAAaQ,KAAKC,EAAkBR,KAAKC,QAAS,SAAS,WAAM,SAAKgB,cAC3EjB,KAAKD,aAAaQ,KAAKC,EAAkBR,KAAKC,QAAS,SAAS,WAAM,SAAKgB,eAGtE,YAAAA,QAAP,WACE,IAAgB,UAAAjB,KAAKD,aAAL,eAAJ,KACRkB,WAIE,YAAAH,UAAR,SAAkBJ,GAGgB,IAA5BV,KAAKC,QAAQiB,YAGjBlB,KAAKC,QAAQkB,KAAKT,IAGZ,YAAAM,YAAR,SAAoBN,GAClB,GAAgC,IAA5BV,KAAKC,QAAQiB,WAAjB,CAIA,IADA,IAAME,EAAS,IAAIR,WAAWF,EAAKW,QAC1BC,EAAI,EAAGA,EAAIZ,EAAKW,SAAUC,EACjCF,EAAOE,GAA0B,IAArBZ,EAAKa,WAAWD,GAE9BtB,KAAKC,QAAQkB,KAAKC,KAEtB,EAtDA,GAwDA,SAASZ,EAAqDX,EAAmB2B,EAASC,GAExF,OADA5B,EAAO6B,iBAAiBF,EAAMC,GACvB,CACLR,QAAS,WACFQ,GAIL5B,EAAO8B,oBAAoBH,EAAMC,KAhE1B,EAAAG,YAAAA,G","sources":["webpack://AttachAddon/webpack/universalModuleDefinition","webpack://AttachAddon/./src/AttachAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AttachAddon\"] = factory();\n\telse\n\t\troot[\"AttachAddon\"] = factory();\n})(self, function() {\nreturn ","/**\n * Copyright (c) 2014, 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * Implements the attach method, that attaches the terminal to a WebSocket stream.\n */\n\nimport { Terminal, IDisposable, ITerminalAddon } from 'xterm';\n\ninterface IAttachOptions {\n  bidirectional?: boolean;\n}\n\nexport class AttachAddon implements ITerminalAddon {\n  private _socket: WebSocket;\n  private _bidirectional: boolean;\n  private _disposables: IDisposable[] = [];\n\n  constructor(socket: WebSocket, options?: IAttachOptions) {\n    this._socket = socket;\n    // always set binary type to arraybuffer, we do not handle blobs\n    this._socket.binaryType = 'arraybuffer';\n    this._bidirectional = !(options && options.bidirectional === false);\n  }\n\n  public activate(terminal: Terminal): void {\n    this._disposables.push(\n      addSocketListener(this._socket, 'message', ev => {\n        const data: ArrayBuffer | string = ev.data;\n        terminal.write(typeof data === 'string' ? data : new Uint8Array(data));\n      })\n    );\n\n    if (this._bidirectional) {\n      this._disposables.push(terminal.onData(data => this._sendData(data)));\n      this._disposables.push(terminal.onBinary(data => this._sendBinary(data)));\n    }\n\n    this._disposables.push(addSocketListener(this._socket, 'close', () => this.dispose()));\n    this._disposables.push(addSocketListener(this._socket, 'error', () => this.dispose()));\n  }\n\n  public dispose(): void {\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n  }\n\n  private _sendData(data: string): void {\n    // TODO: do something better than just swallowing\n    // the data if the socket is not in a working condition\n    if (this._socket.readyState !== 1) {\n      return;\n    }\n    this._socket.send(data);\n  }\n\n  private _sendBinary(data: string): void {\n    if (this._socket.readyState !== 1) {\n      return;\n    }\n    const buffer = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      buffer[i] = data.charCodeAt(i) & 255;\n    }\n    this._socket.send(buffer);\n  }\n}\n\nfunction addSocketListener<K extends keyof WebSocketEventMap>(socket: WebSocket, type: K, handler: (this: WebSocket, ev: WebSocketEventMap[K]) => any): IDisposable {\n  socket.addEventListener(type, handler);\n  return {\n    dispose: () => {\n      if (!handler) {\n        // Already disposed\n        return;\n      }\n      socket.removeEventListener(type, handler);\n    }\n  };\n}\n"],"names":["root","factory","exports","module","define","amd","self","socket","options","_disposables","this","_socket","binaryType","_bidirectional","bidirectional","activate","terminal","push","addSocketListener","ev","data","write","Uint8Array","onData","_sendData","onBinary","_sendBinary","dispose","readyState","send","buffer","length","i","charCodeAt","type","handler","addEventListener","removeEventListener","AttachAddon"],"sourceRoot":""}